import requests
import json
import pandas as pd
from .config import *
from .utils import *

"""
TODO: 
    - filters
    - timeseries
"""


def get_headers(api_key: str):
    """
    Function to create header, based on your Lizard API key

    Parameters:
    ----------
    api key : str
        Your Lizard API Key

    Returns:
    -------
    Lizard headers: dict
    """

    headers = {
        "username": "__key__",
        "password": api_key,
        "Content-Type": "application/json",
    }

    return headers


class Organisation:
    """
    This class takes an organisation uuid or name as argument.
    It enables to obtain all data related to the organisation for the relevant endpoints.
    For example: Organisation.get_locations() returns all locations under the provided organisation.

    NOTE: name option doesn't seem to work for special characters, such as +, & etc. Please lookup the uuid manually, and use it instead of name.

    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    organisation_name: str
        Optional. If not provided, organisation_uuid is required
    organisation_uuid: str
        Optional. If not provided, organisation_name is required
    """

    def __init__(self, headers: dict = None, name: str = None, uuid: str = None):
        self.headers = headers

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise KeyError("No organisation found for provided uuid")
            else:
                self.name = r.json()["name"]
                return
        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/organisations/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]

            if count == 0:
                raise KeyError("No organisation found for provided name")
                
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
                return

    def get_stats(self):
        """
        Returns the amount of assets for the organisation.

        Returns:
        --------
        dictionary {endpoints:count}
        """

        endpoint_list = [
            "filters",
            "groundwaterstations",
            "locations",
            "manholes",
            "measuringstations",
            "monitoringnetworks",
            "pumpstations",
            "rasters",
            "rastersources",
            "scenarios",
            "timeseries",
            "weirs",
            "wmslayers",
        ]

        count_dict = {}

        for endpoint in endpoint_list:
            if endpoint == "timeseries":
                url = f"{LIZARD_BASE_URL}/{endpoint}/?location__organisation__uuid={self.uuid}"
            else:
                url = f"{LIZARD_BASE_URL}/{endpoint}/?organisation__uuid={self.uuid}"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_monitoringnetworks(self, return_format: str = "list"):
        """
        Get all the monitoringngetworks related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        --------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="monitoringnetworks",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results

    def get_groundwaterstations(self, return_format: str = "list"):
        """
        Get all the groundwaterstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="groundwaterstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_pumpstations(self, return_format: str = "list"):
        """
        Get all the pumpstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="pumpstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_measuringstations(self, return_format: str = "list"):
        """
        Get all the measuringstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="measuringstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_locations(self, return_format: str = "list"):
        """
        Get all the locations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="locations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results

    def get_timeseries(self, return_format: str = "list"):
        """
        Get all the timeseries related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="timeseries",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results


class Monitoringnetwork:
    """
    Class for working with monitoringnetworks.
    Initialization requires either name or uuid.

    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    name: str
        Optional. If not provided, uuid is required
    uuid: str
        Optional. If not provided, name is required
    """

    def __init__(self, headers: dict = None, name: str = None, uuid: str = None):
        self.headers = headers

        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/monitoringnetworks/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]
            if count == 0:
                raise KeyError("No monitoringnetwork found for provided name")
                
            if count > 1:
                raise KeyError("Multiple monitoringnetworks found for provided name")
                
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise KeyError("No monitoringnetwork found for provided uuid")
                return
            else:
                self.name = r.json()["name"]


    def get_stats(self):
        """
        Returns the amount of locations, observation_types, and timeseries.

        Returns:
        --------
        dictionary {endpoints:count}

        """
        endpoint_list = ["locations", "observationtypes", "timeseries"]
        count_dict = {}

        for endpoint in endpoint_list:
            url = f"{self.url}/{endpoint}/"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_locations(self, return_format: str = "list"):
        """
        Returns the locations related to the monitoringnetwork in a uuid list or df format

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df

        """
        results = get_monitoringnetwork_enpoint_assets(
            endpoint="locations",
            return_format=return_format,
            url=self.url,
            headers=self.headers,
        )

        return results

    def get_timeseries(self, return_format: str = "list"):
        """
        Returns the timeseries related to the monitoringnetwork in a uuid list or df format

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """

        results = get_monitoringnetwork_enpoint_assets(
            endpoint="timeseries",
            return_format=return_format,
            url=self.url,
            headers=self.headers,
        )

        return results

    def add_timeseries(self, timeseries_uuid_list: list):
        """
        Function to add timeseries to the monitoringnetwork.
        This automatically adds the locations related to the timeseries to the network

        Parameters:
        ------------
        timeseries_uuid_list : list
            list of uuids of the timeseries to add
        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
            return
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.post(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()

    def delete_timeseries(self, timeseries_uuid_list: list):
        """
        Function to delete timeseries to the monitoringnetwork.
        This automatically deletes the locations related to the timeseries to the network

        Parameters:
        ------------
        timeseries_uuid_list : list
            list of uuids of the timeseries to delete

        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
            return
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.delete(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()


class Groundwaterstation:
    """
    Class for working with groundwaterstations.
    Initialization requires groundwaterstation id if the groundwaterstation exists.
    If the groundwaterstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The groundwaterstation id. This should be provided if the groundwaterstation exists allready.
    post_params : dict
        The parameters that are required to create a new groundwaterstation.
        These are:
            organisation, geometry, name, code
        If a new groundwaterstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/groundwaterstations/{self.id}/"
            return
        elif id != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
            
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/groundwaterstations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.id = r.json()["id"]
                self.url = f"{LIZARD_BASE_URL}/groundwaterstations/{self.id}/"
                print(f"Groundwaterstation successfully created with id {self.id}")
            else:
                raise KeyError(r.json())
                


    def get_groundwaterstation_data(self):
        """
        Get the data of the groundwaterstation.

        Returns
        ------
        dictionary : a json field of the data related to the groundwaterstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_groundwaterstation_data(self, patch_params: dict = None):
        """
        Method to update an existing groundwaterstation

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )

        if r.status_code == 200:
            print(f"Groundwaterstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_groundwaterstation(self):
        """
        Deletes the groundwaterstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Groundwaterstation {self.id} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_location(self, return_format: str = "uuid"):
        """
        This method searches the location related to the groundwaterstation

        Parameters:
        -----------
        return_format : str
            options:
                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        string (when return_format = 'uuid')

        dict (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=groundwaterstation"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No locations found for groundwaterstation id {self.id}")
            return
        elif count > 1:
            print(
                "Unexpected result: More than 1 locations are found. If that is possible, this code should be updated"
            )
            return
        elif count == 1:
            if return_format == "uuid":
                uuid = r.json()["results"][0]["uuid"]
                return uuid
            if return_format == "json":
                location_json = r.json()["results"][0]
                return location_json
            
    def get_related_filters(self, return_format: str = "uuid"):
        """
        This method searches the filters related to the groundwaterstation

        Parameters:
        -----------
        return_format : str
            options:
                - 'uuid' (default): returns a list of filter ids

                - 'json': returns a list of the filter json data


        Returns:
        --------
        string (when return_format = 'uuid')

        dict (when return_format = 'json')
        """
        filters = self.get_groundwaterstation_data()['filters']
        
        id_list = []
        json_list = []

        if len(filters) == 0:
            print(f"No filters found for groundwaterstation id {self.id}")
            return
        else:
            for filter in filters:
                if return_format == "uuid":
                    id_list.append(filter['id'])
                if return_format == "json":
                    json_list.append(filter)
            if return_format == "uuid":
                return id_list
            if return_format == "json":
                return json_list       

class Pumpstation:
    """
    Class for working with pumpstations.
    Initialization requires pumpstation id if the pumpstation exists.
    If the pumpstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The pumpstation id. This should be provided if the pumpstation exists allready.
    post_params : dict
        The parameters that are required to create a new pumpstation.

        These are:
            organisation, geometry, name, code
        If a new pumpstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/pumpstations/{self.id}/"
            return
        elif id != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/pumpstations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.id = r.json()["id"]
                self.url = f"{LIZARD_BASE_URL}/pumpstations/{self.id}/"
                print(f"Pumpstation successfully created with id {self.id}")
            else:
                raise KeyError(r.json())
            

    def get_pumpstation_data(self):
        """
        Get the data of the pumpstation.

        Returns
        ------
        dictionary : a json field of the data related to the pumpstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_pumpstation_data(self, patch_params: dict = None):
        """
        Method to update an existing pumpstation

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Pumpstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_pumpstation(self):
        """
        Deletes the pumpstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Pumpstation {self.id} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_location(self, return_format: str = "uuid"):
        """
        This method searches the location related to the pumpstation

        Parameters:
        -----------
        return_format : str
            options:
                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        list[str] (when return_format = 'uuid')

        list[dict] (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=pumpstation&limit=1000"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No locations found for pumpstation id {self.id}")
            return

        elif count != 0:
            uuid_list = []
            json_list = []

            for location in r.json()["results"]:
                if return_format == "uuid":
                    uuid_list.append(location["uuid"])
                if return_format == "json":
                    json_list.append(location)

            if return_format == "uuid":
                return uuid_list
            elif return_format == "json":
                return json_list

class Measuringstation:
    """
    Class for working with measuringstations.
    Initialization requires measuringstation id if the measuringstation exists.
    If the measuringstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The measuringstation id. This should be provided if the measuringstation exists allready.
    post_params : dict
        The parameters that are required to create a new measuringstation.

        These are:
            organisation, geometry, name, code, station_type

            Stationtypes are:

                - WEATHER = 1

                - SEWERAGE = 2

                - SURFACE_WATER = 3

                - OFFSHORE = 4

                - CATCHMENT = 5

                - DMC = 6

                - SEISMOMETER = 7

                - RADAR = 8

                - INFRARED = 9

                - INCLINOMETER = 10

                - FLOWMETER = 11

        If a new measuringstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/measuringstations/{self.id}/"
            return
        elif id != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/measuringstations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.id = r.json()["id"]
                self.url = f"{LIZARD_BASE_URL}/measuringstations/{self.id}/"
                print(f"Measuringstation successfully created with id {self.id}")
            else:
                raise KeyError(r.json())
            

    def get_measuringstation_data(self):
        """
        Get the data of the measuringstation.

        Returns
        ------
        dictionary : a json field of the data related to the measuringstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_measuringstation_data(self, patch_params: dict = None):
        """
        Method to update an existing measuringstation

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Measuringstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_measuringstation(self):
        """
        Deletes the measuringstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Measuringstation {self.id} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_location(self, return_format: str = "uuid"):
        """
        This method searches the location related to the measuringstation

        Parameters:
        -----------
        return_format : str
            options:
                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        list[str] (when return_format = 'uuid')

        list[dict] (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=measuringstation&limit=1000"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No locations found for measuringstation id {self.id}")
            return

        elif count != 0:
            uuid_list = []
            json_list = []

            for location in r.json()["results"]:
                if return_format == "uuid":
                    uuid_list.append(location["uuid"])
                if return_format == "json":
                    json_list.append(location)

            if return_format == "uuid":
                return uuid_list
            elif return_format == "json":
                return json_list


class Location:
    """
    Class for working with locations.
    Initialization requires location uuid if the location exists.
    If the location has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    uuid : str
        The location id. This should be provided if the location exists allready.
    post_params : dict
        The parameters that are required to create a new location.

        These are:
            organisation, geometry, name, code, acces_modifier

        If a new location is created, the uuid is saved on the self.uuid

    """

    def __init__(self, headers: dict = None, uuid: str = None, post_params: dict = None):
        self.headers = headers

        if uuid != None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/locations/{self.uuid}/"
            return
        elif uuid != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
        elif uuid == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/locations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.uuid = r.json()["uuid"]
                self.url = f"{LIZARD_BASE_URL}/locations/{self.uuid}/"
                print(f"Measuringstation successfully created with uuid {self.uuid}")
            else:
                raise KeyError(r.json())


    def get_location_data(self):
        """
        Get the data of the location.

        Returns
        ------
        dictionary : a json field of the data related to the location.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_location_data(self, patch_params: dict = None):
        """
        Method to update an existing location

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Location {self.uuid} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_location(self):
        """
        Deletes the location.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Location {self.uuid} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_timeseries(self, return_format: str = "uuid"):
        """
        This method searches the timeseries related to the location

        Parameters:
        -----------
        return_format : str
            options:
                - 'uuid' (default): returns a list of timeseries uuids

                - 'json': returns the full data in json format of the found timeseries


        Returns:
        --------
        list[str] (when return_format = 'uuid')

        list[dict] (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/timeseries/?location__uuid={self.uuid}&limit=1000"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No timeseries found for location uuid {self.uuid}")
            return

        elif count != 0:
            uuid_list = []
            json_list = []

            for timeserie in r.json()["results"]:
                if return_format == "uuid":
                    uuid_list.append(timeserie["uuid"])
                if return_format == "json":
                    json_list.append(timeserie)

            if return_format == "uuid":
                return uuid_list
            elif return_format == "json":
                return json_list