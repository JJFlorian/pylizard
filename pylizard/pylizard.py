import requests
import json
import pandas as pd
from .config import *
from .utils import *

"""
NOTE: compatible with API v4 only. Import as from pylizard import pylizard as liz

"""

"""
TODO: 
    - organisation
    - groundwaterstations
    - pumpstations
    - measuringstations
    - locations
    - timeseries
"""


def get_headers(api_key):
    """
    Function to create header, based on your Lizard API key
    args:
        - api key
    """
    headers = {
            "username": "__key__",
            "password": api_key,
            "Content-Type": "application/json",
        }

    return headers

class Organisation:
    """
    This class takes an organisation uuid or name as argument.
    It enables to obtain all data related to the organisation for the relevant endpoints.
    For example: Organisation.get_locations() returns all locations under the provided organisation.

    NOTE: name option doesn't seem to work for special characters. Please lookup the uuid manually, and use it instead of name.

    args:
        - headers: Lizard headers. Can be generated by get_headers('API_KEY')
        - organisation_name
        - organisation_uuid
    """

    def __init__(self, headers=None, name=None, uuid=None):
        self.headers = headers
        
        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
            r = requests.get(self.url, headers=self.headers)
            
            if r.status_code != 200:
                raise TypeError("No organisatino found for provided uuid")
            else:
                self.name = r.json()["name"]
        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/organisations/?name={self.name}"
            print(url)
            r = requests.get(url, headers=self.headers)         
            count = r.json()["count"]

            if count == 0:
                raise TypeError("No organisation found for provided name")
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
 
    def get_stats(self):
        """
        Returns the amount of assets for the organisation.
        """
        endpoint_list = [
            'filters',
            'groundwaterstations',
            'locations',
            'manholes',
            'measuringstations',
            'monitoringnetworks',
            'pumpstations',
            'rasters',
            'rastersources',
            'scenarios',
            'timeseries',
            'weirs',
            'wmslayers',
        ]

        count_dict = {}

        for endpoint in endpoint_list:
            if endpoint == 'timeseries':
                url = f"{LIZARD_BASE_URL}/{endpoint}/?location__organisation__uuid={self.uuid}"
            else:
                url = f"{LIZARD_BASE_URL}/{endpoint}/?organisation__uuid={self.uuid}"
            
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_monitoringnetworks(self, dataformat='list'):
        """
        Get all the monitoringngetworks related to the organisation.

        args:
            - dataformat: 'list' for list of uuids, 'df' for df of all data

        returns:
            - list of monitoringnetwork uuids
        """
        results = get_organisation_endpoint_assets(endpoint='monitoringnetworks', dataformat=dataformat, organisation_uuid=self.uuid, json_field='uuid', headers=self.headers)
        
        return results

    def get_groundwaterstations(self, dataformat='list'):
        """
        Get all the groundwaterstations related to the organisation.

        args:
            - dataformat: 'list' for list of ids, 'df' for df of all data

        returns:
            - list of groundwaterstations ids
        """
        results = get_organisation_endpoint_assets(endpoint='groundwaterstations', dataformat=dataformat, organisation_uuid=self.uuid, json_field='id', headers=self.headers)
        
        return results
  
    def get_pumpstations(self, dataformat='list'):
        """
        Get all the pumpstations related to the organisation.

        args:
            - dataformat: 'list' for list of ids, 'df' for df of all data

        returns:
            - list of pumpstations ids
        """
        results = get_organisation_endpoint_assets(endpoint='pumpstations', dataformat=dataformat, organisation_uuid=self.uuid, json_field='id', headers=self.headers)
        
        return results
    
    def get_measuringstations(self, dataformat='list'):
        """
        Get all the measuringstations related to the organisation.

        args:
            - dataformat: 'list' for list of ids, 'df' for df of all data

        returns:
            - list of measuringstations uuids
        """
        results = get_organisation_endpoint_assets(endpoint='measuringstations', dataformat=dataformat, organisation_uuid=self.uuid, json_field='id', headers=self.headers)
        
        return results

    def get_locations(self, dataformat='list'):
        """
        Get all the locations related to the organisation.

        args:
            - dataformat: 'list' for list of uuids, 'df' for df of all data

        returns:
            - list of locations uuids
        """
        results = get_organisation_endpoint_assets(endpoint='locations', dataformat=dataformat, organisation_uuid=self.uuid, json_field='uuid', headers=self.headers)
        
        return results

    def get_timeseries(self, dataformat='list'):
        """
        Get all the timeseries related to the organisation.

        args:
            - dataformat: 'list' for list of uuids, 'df' for df of all data

        returns:
            - list of timeseries uuids
        """
        results = get_organisation_endpoint_assets(endpoint='timeseries', dataformat=dataformat, organisation_uuid=self.uuid, json_field='uuid', headers=self.headers)
        
        return results
    

class Monitoringnetwork:
    """
    Class for working with monitoringnetworks.
    Initialization requires either name or uuid.
    
    args:
        -headers: Lizard headers. Can be generated by get_headers('API_KEY')
        -name
        -uuid
    """

    def __init__(self, headers=None, name=None, uuid=None):
        self.headers = headers

        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/monitoringnetworks/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]
            if count == 0:
                raise TypeError("No monitoringnetwork found for provided name")
            if count > 1:
                raise TypeError("Multiple monitoringnetworks found for provided name")
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise TypeError("No monitoringnetwork found for provided uuid")
            else:
                self.name = r.json()["name"]

    def get_stats(self):
        """
        Returns the amount of locations, observation_types, and timeseries.

        """
        endpoint_list = ['locations','observationtypes','timeseries']
        count_dict = {}

        for endpoint in endpoint_list:
            url = f"{self.url}/{endpoint}/"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_locations(self, dataformat="list"):
        """
        Returns the locations related to the monitoringnetwork in a uuid list or df format
        args:
            - dataformat: 'list' or 'df'

        returns:
            - list of uuids ('list')
            - DataFrame of all data ('df')
        """
        uuid_list = []
        df_list = []
        next_url = f"{self.url}/locations/?limit=250"

        while next_url != None:
            r = requests.get(next_url, headers=self.headers)
            results = r.json()["results"]

            if dataformat == "list":
                for result in results:
                    uuid_list.append(result["uuid"])
            elif dataformat == "df":
                for result in results:
                    df_list.append(result)

            next_url = r.json()["next"]

        if dataformat == "list":
            return uuid_list
        elif dataformat == "df":
            df = pd.DataFrame(df_list)
            return df

    def get_timeseries(self, dataformat="list"):
        """
        Returns the timeseries related to the monitoringnetwork in a uuid list or df format
        args:
            - dataformat: 'list' or 'df'

        returns:
            - list of uuids ('list')
            - DataFrame of all data ('df')
        """
        uuid_list = []
        df_list = []
        next_url = f"{self.url}/timeseries/?limit=250"

        while next_url != None:
            r = requests.get(next_url, headers=self.headers)
            results = r.json()["results"]

            if dataformat == "list":
                for result in results:
                    uuid_list.append(result["uuid"])
            elif dataformat == "df":
                for result in results:
                    df_list.append(result)

            next_url = r.json()["next"]

        if dataformat == "list":
            return uuid_list
        elif dataformat == "df":
            df = pd.DataFrame(df_list)
            return df

    def add_timeseries(self, timeseries_uuid_list):
        """
        Function to add timeseries to the monitoringnetwork.
        This automatically adds the locations related to the timeseries to the network

        args:
            - a list of uuids of the timeseries to add
        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.post(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()

    def delete_timeseries(self, timeseries_uuid_list):
        """
        Function to delete timeseries to the monitoringnetwork.
        This automatically deletes the locations related to the timeseries to the network

        args:
            - a list of uuids of the timeseries to delete
        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.delete(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()

# class Groundwaterstations:
#     """
#     Class for working with monitoringnetworks.
#     Initialization requires either uuid or organisation uuid.
#     If uuid is given, the class handles the provided groundwaterstation.
#     When the organisation uuid is provided, all the groundwaterstations under the organisation are used.

    
#     args:
#         -headers: Lizard headers. Can be generated by get_headers('API_KEY')
#         -name
#         -uuid
#     """

#     def __init__(self, headers=None, uuid=None):
#         self.headers = headers
#         self.uuid = uuid
