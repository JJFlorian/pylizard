import requests
import json
import pandas as pd
import numpy as np
from .config import *
from .utils import *

"""
TODO: 
    - als asset/location/timeserie wordt geinitieerd -> meteen een get_data() uitvoeren en de 
            resultaten als self opslaan. 

"""


def get_headers(api_key: str):
    """
    Function to create header, based on your Lizard API key

    Parameters:
    ----------
    api key : str
        Your Lizard API Key

    Returns:
    -------
    Lizard headers: dict
    """

    headers = {
        "username": "__key__",
        "password": api_key,
        "Content-Type": "application/json",
    }

    return headers


class Organisation:
    """
    This class takes an organisation uuid or name as argument.
    It enables to obtain all data related to the organisation for the relevant endpoints.
    For example: Organisation.get_locations() returns all locations under the provided organisation.

    NOTE: name option doesn't seem to work for special characters, such as +, & etc. Please lookup the uuid manually, and use it instead of name.

    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    organisation_name: str
        Optional. If not provided, organisation_uuid is required
    organisation_uuid: str
        Optional. If not provided, organisation_name is required
    """

    def __init__(self, headers: dict = None, name: str = None, uuid: str = None):
        self.headers = headers

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise KeyError("No organisation found for provided uuid")
            else:
                self.name = r.json()["name"]
                return
        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/organisations/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]

            if count == 0:
                raise KeyError("No organisation found for provided name")
                
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
                return

    def get_stats(self):
        """
        Returns the amount of assets for the organisation.

        Returns:
        --------
        dictionary {endpoints:count}
        """

        endpoint_list = [
            "groundwaterstations",
            "locations",
            "manholes",
            "measuringstations",
            "monitoringnetworks",
            "pumpstations",
            "rasters",
            "rastersources",
            "scenarios",
            "timeseries",
            "weirs",
            "wmslayers",
        ]

        count_dict = {}

        for endpoint in endpoint_list:
            if endpoint == "timeseries":
                url = f"{LIZARD_BASE_URL}/{endpoint}/?location__organisation__uuid={self.uuid}"
            else:
                url = f"{LIZARD_BASE_URL}/{endpoint}/?organisation__uuid={self.uuid}"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_monitoringnetworks(self, return_format: str = "list"):
        """
        Get all the monitoringngetworks related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        --------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="monitoringnetworks",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results

    def get_groundwaterstations(self, return_format: str = "list"):
        """
        Get all the groundwaterstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="groundwaterstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_pumpstations(self, return_format: str = "list"):
        """
        Get all the pumpstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="pumpstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_measuringstations(self, return_format: str = "list"):
        """
        Get all the measuringstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="measuringstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_locations(self, return_format: str = "list"):
        """
        Get all the locations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="locations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results

    def get_timeseries(self, return_format: str = "list"):
        """
        Get all the timeseries related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="timeseries",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results


class Monitoringnetwork:
    """
    Class for working with monitoringnetworks.
    Initialization requires either name or uuid.

    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    name: str
        Optional. If not provided, uuid is required
    uuid: str
        Optional. If not provided, name is required
    """

    def __init__(self, headers: dict = None, name: str = None, uuid: str = None):
        self.headers = headers

        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/monitoringnetworks/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]
            if count == 0:
                raise KeyError("No monitoringnetwork found for provided name")
                
            if count > 1:
                raise KeyError("Multiple monitoringnetworks found for provided name")
                
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise KeyError("No monitoringnetwork found for provided uuid")
                return
            else:
                self.name = r.json()["name"]


    def get_stats(self):
        """
        Returns the amount of locations, observation_types, and timeseries.

        Returns:
        --------
        dictionary {endpoints:count}

        """
        endpoint_list = ["locations", "observationtypes", "timeseries"]
        count_dict = {}

        for endpoint in endpoint_list:
            url = f"{self.url}/{endpoint}/"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_locations(self, return_format: str = "list"):
        """
        Returns the locations related to the monitoringnetwork in a uuid list or df format

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df

        """
        results = get_monitoringnetwork_enpoint_assets(
            endpoint="locations",
            return_format=return_format,
            url=self.url,
            headers=self.headers,
        )

        return results

    def get_timeseries(self, return_format: str = "list"):
        """
        Returns the timeseries related to the monitoringnetwork in a uuid list or df format

        Parameters:
        ----------
        return_format: str
            options:

                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """

        results = get_monitoringnetwork_enpoint_assets(
            endpoint="timeseries",
            return_format=return_format,
            url=self.url,
            headers=self.headers,
        )

        return results

    def add_timeseries(self, timeseries_uuid_list: list):
        """
        Function to add timeseries to the monitoringnetwork.
        This automatically adds the locations related to the timeseries to the network

        Parameters:
        ------------
        timeseries_uuid_list : list
            list of uuids of the timeseries to add
        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
            return
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.post(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()

    def delete_timeseries(self, timeseries_uuid_list: list):
        """
        Function to delete timeseries to the monitoringnetwork.
        This automatically deletes the locations related to the timeseries to the network

        Parameters:
        ------------
        timeseries_uuid_list : list
            list of uuids of the timeseries to delete

        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
            return
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.delete(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()


class Groundwaterstation:
    """
    Class for working with groundwaterstations.
    Initialization requires groundwaterstation id if the groundwaterstation exists.
    If the groundwaterstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The groundwaterstation id. This should be provided if the groundwaterstation exists allready.
    post_params : dict
        The parameters that are required to create a new groundwaterstation.
        These are:
            organisation, geometry, name, code
        If a new groundwaterstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/groundwaterstations/{self.id}/"
            return
        elif id != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
            
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/groundwaterstations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.id = r.json()["id"]
                self.url = f"{LIZARD_BASE_URL}/groundwaterstations/{self.id}/"
                print(f"Groundwaterstation successfully created with id {self.id}")
            else:
                raise KeyError(r.json())
                


    def get_groundwaterstation_data(self):
        """
        Get the data of the groundwaterstation.

        Returns
        ------
        dictionary : a json field of the data related to the groundwaterstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_groundwaterstation_data(self, patch_params: dict = None):
        """
        Method to update an existing groundwaterstation

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )

        if r.status_code == 200:
            print(f"Groundwaterstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_groundwaterstation(self):
        """
        Deletes the groundwaterstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Groundwaterstation {self.id} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_location(self, return_format: str = "uuid"):
        """
        This method searches the location related to the groundwaterstation

        Parameters:
        -----------
        return_format : str
            options:

                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        string (when return_format = 'uuid')

        dict (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=groundwaterstation"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No locations found for groundwaterstation id {self.id}")
            return
        elif count > 1:
            print(
                "Unexpected result: More than 1 locations are found. If that is possible, this code should be updated"
            )
            return
        elif count == 1:
            if return_format == "uuid":
                uuid = r.json()["results"][0]["uuid"]
                return uuid
            if return_format == "json":
                location_json = r.json()["results"][0]
                return location_json
            
    def get_related_filters(self, return_format: str = "id"):
        """
        This method searches the filters related to the groundwaterstation. Returns a list of urls

        Returns:
        --------
        list[str]
        """
        filters = self.get_groundwaterstation_data()['filters']
        
        id_list = []
        json_list = []

        if len(filters) == 0:
            print(f"No filters found for groundwaterstation id {self.id}")
            return
        else:
            for filter in filters:
                if return_format == "id":
                    id_list.append(filter['id'])
                if return_format == "json":
                    json_list.append(filter)
            if return_format == "id":
                return id_list
            if return_format == "json":
                return json_list     

    def get_related_filter_timeseries(self):
        """
        This method searches the timeseries related to the groundwaterstation via the filters

        Parameters:
        -----------
        return_format : str
            options:

                - 'uuid' (default): returns a list of filter ids

                - 'json': returns a list of the filter json data


        Returns:
        --------
        list[str] (when return_format = 'id')

        list[dict] (when return_format = 'json')
        """
        filters = self.get_groundwaterstation_data()['filters']
        
        url_list = []

        if len(filters) == 0:
            print(f"No filters, and thus timeseries, were found for groundwaterstation id {self.id}")
            return
        else:
            for filter in filters:
                if filter['timeseries']:
                    for timeserie in filter['timeseries']:
                        url_list.append(timeserie)

        return url_list

class Pumpstation:
    """
    Class for working with pumpstations.
    Initialization requires pumpstation id if the pumpstation exists.
    If the pumpstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The pumpstation id. This should be provided if the pumpstation exists allready.
    post_params : dict
        The parameters that are required to create a new pumpstation.

        These are:
            organisation, geometry, name, code
        If a new pumpstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/pumpstations/{self.id}/"
            return
        elif id != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/pumpstations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.id = r.json()["id"]
                self.url = f"{LIZARD_BASE_URL}/pumpstations/{self.id}/"
                print(f"Pumpstation successfully created with id {self.id}")
            else:
                raise KeyError(r.json())
            

    def get_pumpstation_data(self):
        """
        Get the data of the pumpstation.

        Returns
        ------
        dictionary : a json field of the data related to the pumpstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_pumpstation_data(self, patch_params: dict = None):
        """
        Method to update an existing pumpstation

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Pumpstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_pumpstation(self):
        """
        Deletes the pumpstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Pumpstation {self.id} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_location(self, return_format: str = "uuid"):
        """
        This method searches the location related to the pumpstation

        Parameters:
        -----------
        return_format : str
            options:

                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        list[str] (when return_format = 'uuid')

        list[dict] (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=pumpstation&limit=1000"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No locations found for pumpstation id {self.id}")
            return

        elif count != 0:
            uuid_list = []
            json_list = []

            for location in r.json()["results"]:
                if return_format == "uuid":
                    uuid_list.append(location["uuid"])
                if return_format == "json":
                    json_list.append(location)

            if return_format == "uuid":
                return uuid_list
            elif return_format == "json":
                return json_list

class Measuringstation:
    """
    Class for working with measuringstations.
    Initialization requires measuringstation id if the measuringstation exists.
    If the measuringstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The measuringstation id. This should be provided if the measuringstation exists allready.
    post_params : dict
        The parameters that are required to create a new measuringstation.

        These are:
            organisation, geometry, name, code, station_type

            Stationtypes are:

                - WEATHER = 1

                - SEWERAGE = 2

                - SURFACE_WATER = 3

                - OFFSHORE = 4

                - CATCHMENT = 5

                - DMC = 6

                - SEISMOMETER = 7

                - RADAR = 8

                - INFRARED = 9

                - INCLINOMETER = 10

                - FLOWMETER = 11

        If a new measuringstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/measuringstations/{self.id}/"
            return
        elif id != None and post_params != None:
            raise KeyError("Please provide either id or post_params. Not both.")
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/measuringstations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.id = r.json()["id"]
                self.url = f"{LIZARD_BASE_URL}/measuringstations/{self.id}/"
                print(f"Measuringstation successfully created with id {self.id}")
            else:
                raise KeyError(r.json())
            

    def get_measuringstation_data(self):
        """
        Get the data of the measuringstation.

        Returns
        ------
        dictionary : a json field of the data related to the measuringstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_measuringstation_data(self, patch_params: dict = None):
        """
        Method to update an existing measuringstation

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Measuringstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_measuringstation(self):
        """
        Deletes the measuringstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Measuringstation {self.id} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_location(self, return_format: str = "uuid"):
        """
        This method searches the location related to the measuringstation

        Parameters:
        -----------
        return_format : str
            options:

                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        list[str] (when return_format = 'uuid')

        list[dict] (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=measuringstation&limit=1000"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No locations found for measuringstation id {self.id}")
            return

        elif count != 0:
            uuid_list = []
            json_list = []

            for location in r.json()["results"]:
                if return_format == "uuid":
                    uuid_list.append(location["uuid"])
                if return_format == "json":
                    json_list.append(location)

            if return_format == "uuid":
                return uuid_list
            elif return_format == "json":
                return json_list


class Location:
    """
    Class for working with locations.
    Initialization requires location uuid if the location exists.
    If the location has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    uuid : str
        The location uuid. This should be provided if the location exists allready.
    post_params : dict
        The parameters that are required to create a new location.

        These are:
            organisation, geometry, name, code, acces_modifier

        If a new location is created, the uuid is saved on the self.uuid

    """

    def __init__(self, headers: dict = None, uuid: str = None, post_params: dict = None):
        self.headers = headers

        if uuid != None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/locations/{self.uuid}/"
            return
        elif uuid != None and post_params != None:
            raise KeyError("Please provide either uuid or post_params. Not both.")
        elif uuid == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/locations/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.uuid = r.json()["uuid"]
                self.url = f"{LIZARD_BASE_URL}/locations/{self.uuid}/"
                print(f"Location successfully created with uuid {self.uuid}")
            else:
                raise KeyError(r.json())


    def get_location_data(self):
        """
        Get the data of the location.

        Returns
        ------
        dictionary : a json field of the data related to the location.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_location_data(self, patch_params: dict = None):
        """
        Method to update an existing location

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Location {self.uuid} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_location(self):
        """
        Deletes the location.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Location {self.uuid} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_related_timeseries(self, return_format: str = "uuid"):
        """
        This method searches the timeseries related to the location

        Parameters:
        -----------
        return_format : str
            options:

                - 'uuid' (default): returns a list of timeseries uuids

                - 'json': returns the full data in json format of the found timeseries


        Returns:
        --------
        list[str] (when return_format = 'uuid')

        list[dict] (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/timeseries/?location__uuid={self.uuid}&limit=1000"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()["count"]

        if count == 0:
            print(f"No timeseries found for location uuid {self.uuid}")
            return

        elif count != 0:
            uuid_list = []
            json_list = []

            for timeserie in r.json()["results"]:
                if return_format == "uuid":
                    uuid_list.append(timeserie["uuid"])
                if return_format == "json":
                    json_list.append(timeserie)

            if return_format == "uuid":
                return uuid_list
            elif return_format == "json":
                return json_list
            
class Timeserie:
    """
    Class for working with timeseries.
    Initialization requires timeserie uuid if the timeserie exists.
    If the timeserie has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    uuid : str
        The timeserie uuid. This should be provided if the timeserie exists allready.
    post_params : dict
        The parameters that are required to create a new timeserie.

        These are:
            organisation, name, code, acces_modifier, observation_type, value_type

        If a new location is created, the uuid is saved on the self.uuid

    """

    def __init__(self, headers: dict = None, uuid: str = None, post_params: dict = None):
        self.headers = headers

        if uuid != None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/timeseries/{self.uuid}/"
            return
        elif uuid != None and post_params != None:
            raise KeyError("Please provide either uuid or post_params. Not both.")
        elif uuid == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/timeseries/"
            r = requests.post(
                url=url, headers=self.headers, data=json.dumps(post_params)
            )
            if r.status_code == 201:
                self.uuid = r.json()["uuid"]
                self.url = f"{LIZARD_BASE_URL}/timeseries/{self.uuid}/"
                print(f"Timeserie successfully created with uuid {self.uuid}")
            else:
                raise KeyError(r.json())


    def get_timeserie_data(self):
        """
        Get the data of the timeserie.

        Returns
        ------
        dictionary : a json field of the data related to the location.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results

    def update_timeserie_data(self, patch_params: dict = None):
        """
        Method to update an existing timeserie

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(
            url=self.url, headers=self.headers, data=json.dumps(patch_params)
        )
        if r.status_code == 200:
            print(f"Timeserie {self.uuid} successfully updated")
        else:
            raise KeyError(r.json())

    def delete_timeserie(self):
        """
        Deletes the timeserie.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Timeserie {self.uuid} successfully deleted")
        else:
            raise KeyError(r.json())

    def get_aggregated_data(self, return_format: str = "json", fields: str = None, start: str = None, end: str = None, window: str = None):
        """
        This method gets the aggregated data of the timeserie, based on the provided parameters

        Parameters:
        -----------
        return_format : str
            options:

                - 'json' (default): returns the data in json format

                - 'df': returns the data in a pandas DataFrame format

        fields : str
            List of aggregation fields to retrieve. Options depend on the so-called value_type of the timeseries:
                    *Numerical value type*: time, avg, min, max, sum, first, last, first_timestamp, last_timestamp, min_timestamp, max_timestamp, count,nans.

                    *Boolean value type*: time, sum, first, last, first_timestamp, last_timestamp, count.

                    *String value type*: time, first, last, first_timestamp, last_timestamp, coun
        start : str
            The first element of a half-open interval. Datetime as an ISO 8601 string. If no time zone is provided, UTC is assumed. The total period considered is either [start, end) or (start, end], depending on the closed query parameter.
        
        end : str
            The last element of a half-open interval. Datetime as an ISO 8601 string. If no time zone is provided, UTC is assumed. The total period considered is either [start, end) or (start, end], depending on the closed query parameter.
        
        window : str
            Temporal window (aka buckets or bins) to aggregate the data in, e.g. "hour", "day", "week". Strings may be prefixed by a multiplier, for example: "3hour", "2 weeks", etc. "window=user" defines a single [start, end) or (start, end] bucket, depending on the closed query parameter.

        Returns:
        --------
        list[dict] (when return_format = 'json')
        DataFrame (object): when return_format = 'pd'
        """
    
        if fields == None or start == None or end == None or window == None:
            raise KeyError("Not all parameters are provided!")
        else:
            url = f"{self.url}aggregates/?fields={fields}&start={start}&end={end}&window={window}"
            r = requests.get(url=url, headers=self.headers)
            results = r.json()['results']

            if return_format == 'json':
                return results
            elif return_format == 'df':
                df = pd.DataFrame(results)
                return df
            
    def get_events(self, return_format: str = "json", time_range: str = None, extra_parameters: str = None):
        """
        This method gets the events data of the timeserie, based on the provided parameters

        Parameters:
        -----------
        return_format : str
        
            options:

                - 'json' (default): returns the data in json format

                - 'df': returns the data in a pandas DataFrame format

        time_range : str

            start and end date for the events query, separated by a comma.
            Example format: '2020-04-23T00:00:00Z,2022-04-23T00:00:00Z.
            Optional: if not provided, all events will be returned.

        extra_parameters : str

            String of the extra query parameters. Example: 'flag__in=5,6,7&value=0.5'
            Check the documentation on the event page for a random timeserie as example.
        
        Returns:
        --------
        list[dict] (when return_format = 'json')
        DataFrame (object): when return_format = 'pd'
        """

        next_url = f"{self.url}events/?limit=1000"
        if time_range != None:
            next_url = f"{next_url}&time__range={time_range}"
        if extra_parameters != None:
            next_url = f"{next_url}&{extra_parameters}"
        
        event_list = []

        while next_url != None:
            r = requests.get(url=next_url, headers=self.headers)
            events = r.json()['results']
            for event in events:
                event_list.append(event)
            next_url= r.json()['next']

        if return_format == 'json':
            return event_list
        elif return_format == 'df':
            df = pd.DataFrame(event_list)
            return df
   
    def add_events(self, data_list: list = None, data_df: pd.DataFrame = None):
        """
        Method to add events to the timeserie.

        Parameters:
        -----------
        data : list of objects or df

            Lizard accepts JSON or csv as dataformat. 
            For now PyLizard only supports JSON or a df.
            PyLizard transforms the df into the required format.
            When a df is provided, make sure to have a 'time' and 'value' column
            
            Example input:

            [
                {"time": "2020-03-20T01:00:00Z", "value": 3.14},
                {"time": "2020-03-20T01:05:00Z", "value": 2.72}
            ]
        
        """
        if data_list != None:
            df = pd.DataFrame(data_list).set_index("time")
            df = df[~df.index.duplicated(keep='last')].reset_index()
            df_duplicates_removed = df.replace({np.nan:None}).to_dict('records')
            lizard_upload_url = f"{self.url}events/"
            payload = json.dumps(df_duplicates_removed)
            r = requests.post(url=lizard_upload_url, headers=self.headers, data=payload)

        if not data_df.empty:
            data_df = data_df.set_index("time")
            data_df = data_df[~data_df.index.duplicated(keep='last')].reset_index()
            df_duplicates_removed = data_df.replace({np.nan:None}).to_dict('records')
            lizard_upload_url = f"{self.url}events/"
            payload = json.dumps(df_duplicates_removed)
            r = requests.post(url=lizard_upload_url, headers=self.headers, data=payload)
            r.raise_for_status()

    def delete_events(self, data_list: list = None, data_df: pd.DataFrame = None):
        """
        Method to delete events from the timeserie.

        Parameters:
        -----------
        data : list of objects or df

            Lizard accepts JSON or csv as dataformat. 
            For now PyLizard only supports JSON or a df.
            PyLizard transforms the df into the required format.
            When a df is provided, make sure to have a 'time' and 'value' column
            
            Example input:

            [
                {"time": "2020-03-20T01:00:00Z", "value": 3.14},
                {"time": "2020-03-20T01:05:00Z", "value": 2.72}
            ]
        
        """
        if data_list != None:
            df = pd.DataFrame(data_list).set_index("time")
            df = df[~df.index.duplicated(keep='last')].reset_index()
            df_duplicates_removed = df.replace({np.nan:None}).to_dict('records')
            lizard_upload_url = f"{self.url}events/"
            payload = json.dumps(df_duplicates_removed)
            r = requests.delete(url=lizard_upload_url, headers=self.headers, data=payload)

        if not data_df.empty:
            data_df = data_df.set_index("time")
            data_df = data_df[~data_df.index.duplicated(keep='last')].reset_index()
            df_duplicates_removed = data_df.replace({np.nan:None}).to_dict('records')
            lizard_upload_url = f"{self.url}events/"
            payload = json.dumps(df_duplicates_removed)
            r = requests.delete(url=lizard_upload_url, headers=self.headers, data=payload)
            r.raise_for_status()

    
    def get_percentiles(self, percentiles: str = None, start: str = None, end: str = None):
        """
        Get the provided percentiles of the timeseries.

        Parameters:
        -----------
    
        percentiles : str
            comma seperated percentiles (e.g: '25,50,75')
        
        start : str
            Datetime as an ISO 8601 string
        
        end : str
            Datetime as an ISO 8601 string.
       
        Returns:
        --------
        list[lists]
        """
    
        if percentiles == None:
            raise KeyError("Please provide the percentiles")
        else:
            url = f"{self.url}percentiles/?percentiles={percentiles}"
            if start != None:
                url = f"{url}&start={start}"
            if end != None:
                url = f"{url}&end={end}"

            r = requests.get(url=url, headers=self.headers)
            results = r.json()['results']

            return results