import requests
import json
import pandas as pd
from .config import *
from .utils import *

"""
TODO: 
    - pumpstations
    - measuringstations
    - locations
    - timeseries
"""


def get_headers(api_key: str):
    """
    Function to create header, based on your Lizard API key
    
    Parameters:
    ----------
    api key : str
        Your Lizard API Key

    Returns:
    -------
    Lizard headers: dict
    """

    headers = {
        "username": "__key__",
        "password": api_key,
        "Content-Type": "application/json",
    }

    return headers


class Organisation:
    """
    This class takes an organisation uuid or name as argument.
    It enables to obtain all data related to the organisation for the relevant endpoints.
    For example: Organisation.get_locations() returns all locations under the provided organisation.

    NOTE: name option doesn't seem to work for special characters, such as +, & etc. Please lookup the uuid manually, and use it instead of name.

    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    organisation_name: str
        Optional. If not provided, organisation_uuid is required
    organisation_uuid: str
        Optional. If not provided, organisation_name is required
    """

    def __init__(self, headers: dict = None, name: str = None, uuid: str = None):
        self.headers = headers

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"
            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise TypeError("No organisation found for provided uuid")
            else:
                self.name = r.json()["name"]
        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/organisations/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]

            if count == 0:
                raise TypeError("No organisation found for provided name")
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/organisations/{self.uuid}"

    def get_stats(self):
        """
        Returns the amount of assets for the organisation.

        Returns:
        --------
        dictionary {endpoints:count}
        """

        endpoint_list = [
            "filters",
            "groundwaterstations",
            "locations",
            "manholes",
            "measuringstations",
            "monitoringnetworks",
            "pumpstations",
            "rasters",
            "rastersources",
            "scenarios",
            "timeseries",
            "weirs",
            "wmslayers",
        ]

        count_dict = {}

        for endpoint in endpoint_list:
            if endpoint == "timeseries":
                url = f"{LIZARD_BASE_URL}/{endpoint}/?location__organisation__uuid={self.uuid}"
            else:
                url = f"{LIZARD_BASE_URL}/{endpoint}/?organisation__uuid={self.uuid}"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_monitoringnetworks(self, return_format: str = "list"):
        """
        Get all the monitoringngetworks related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        --------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="monitoringnetworks",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results

    def get_groundwaterstations(self, return_format: str = "list"):
        """
        Get all the groundwaterstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="groundwaterstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_pumpstations(self, return_format: str = "list"):
        """
        Get all the pumpstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="pumpstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_measuringstations(self, return_format: str = "list"):
        """
        Get all the measuringstations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of ids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="measuringstations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="id",
            headers=self.headers,
        )

        return results

    def get_locations(self, return_format: str = "list"):
        """
        Get all the locations related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="locations",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results

    def get_timeseries(self, return_format: str = "list"):
        """
        Get all the timeseries related to the organisation.

        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        results = get_organisation_endpoint_assets(
            endpoint="timeseries",
            return_format=return_format,
            organisation_uuid=self.uuid,
            json_field="uuid",
            headers=self.headers,
        )

        return results


class Monitoringnetwork:
    """
    Class for working with monitoringnetworks.
    Initialization requires either name or uuid.

    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    name: str
        Optional. If not provided, uuid is required
    uuid: str
        Optional. If not provided, name is required
    """

    def __init__(self, headers: dict = None, name: str = None, uuid: str = None):
        self.headers = headers

        if uuid == None:
            self.name = name
            url = f"{LIZARD_BASE_URL}/monitoringnetworks/?name={self.name}"
            r = requests.get(url, headers=self.headers)
            count = r.json()["count"]
            if count == 0:
                raise TypeError("No monitoringnetwork found for provided name")
            if count > 1:
                raise TypeError("Multiple monitoringnetworks found for provided name")
            else:
                self.uuid = r.json()["results"][0]["uuid"]
                self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

        if name == None:
            self.uuid = uuid
            self.url = f"{LIZARD_BASE_URL}/monitoringnetworks/{self.uuid}"

            r = requests.get(self.url, headers=self.headers)

            if r.status_code != 200:
                raise TypeError("No monitoringnetwork found for provided uuid")
            else:
                self.name = r.json()["name"]

    def get_stats(self):
        """
        Returns the amount of locations, observation_types, and timeseries.

        Returns:
        --------
        dictionary {endpoints:count}

        """
        endpoint_list = ["locations", "observationtypes", "timeseries"]
        count_dict = {}

        for endpoint in endpoint_list:
            url = f"{self.url}/{endpoint}/"
            r = requests.get(url=url, headers=self.headers)
            count = r.json()["count"]

            count_dict[endpoint] = count

        return count_dict

    def get_locations(self, return_format: str = "list"):
        """
        Returns the locations related to the monitoringnetwork in a uuid list or df format
        
        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        
        """
        results = get_monitoringnetwork_enpoint_assets(
            endpoint="locations",
            return_format=return_format,
            url=self.url,
            headers=self.headers,
        )

        return results

    def get_timeseries(self, return_format: str = "list"):
        """
        Returns the timeseries related to the monitoringnetwork in a uuid list or df format
        
        Parameters:
        ----------
        return_format: str
            options:
                -'list' (default): returns list of uuids

                -'df': returns df of all data

        Returns:
        -------
            list or df
        """
        
        results = get_monitoringnetwork_enpoint_assets(
            endpoint="timeseries",
            return_format=return_format,
            url=self.url,
            headers=self.headers,
        )

        return results

    def add_timeseries(self, timeseries_uuid_list: list):
        """
        Function to add timeseries to the monitoringnetwork.
        This automatically adds the locations related to the timeseries to the network

        Parameters:
        ------------
        timeseries_uuid_list : list
            list of uuids of the timeseries to add
        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.post(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()

    def delete_timeseries(self, timeseries_uuid_list: list):
        """
        Function to delete timeseries to the monitoringnetwork.
        This automatically deletes the locations related to the timeseries to the network

        Parameters:
        ------------
        timeseries_uuid_list : list
            list of uuids of the timeseries to delete

        """
        if len(timeseries_uuid_list) == 0:
            print("The provided list of uuids is empty.")
        else:
            post_url = f"{self.url}/timeseries/"
            r = requests.delete(
                url=post_url,
                headers=self.headers,
                data=json.dumps(timeseries_uuid_list),
            )
            r.raise_for_status()


class Groundwaterstations:
    """
    Class for working with groundwaterstations.
    Initialization requires groundwaterstation id if the groundwaterstation exists.
    If the groundwaterstation has yet to be created, the post_params should be provided


    Parameters:
    -----------
    headers : dict
        Lizard headers. Can be generated by get_headers function
    id : int
        The groundwaterstation id. This should be provided if the groundwaterstation exists allready.
    post_params : dict
        The parameters that are required to create a new groundwaterstation.
        These are:
            organisation, geometry, name, code 
        If a new groundwaterstation is created, the id is saved on the self.id

    """

    def __init__(self, headers: dict = None, id: int = None, post_params: dict = None):
        self.headers = headers

        if id != None:
            self.id = id
            self.url = f"{LIZARD_BASE_URL}/groundwaterstations/{self.id}"
        elif id != None and post_params != None:
            raise TypeError("Please provide either id or post_params. Not both.")
        elif id == None and post_params != None:
            url = f"{LIZARD_BASE_URL}/groundwaterstations/"
            r = requests.post(url=url, headers=self.headers, data=json.dumps(post_params))
            if r.status_code == 400:
                raise KeyError(r.json())
            elif r.status_code == 201:
                self.id = r.json()['id']
                self.url = f"{LIZARD_BASE_URL}/groundwaterstations/{self.id}"
                print(f"Groundwaterstation successfully created with id {self.id}")
    
    def get_groundwaterstation_data(self):
        """
        Get the data of the groundwaterstation.

        Returns
        ------
        dictionary : a json field of the data related to the groundwaterstation.

        """
        r = requests.get(url=self.url, headers=self.headers)
        results = r.json()

        return results
    
    def update_groundwaterstation_data(self, patch_params: dict = None):
        """
        Method to update an existing groundwaterstation

        !!!!NOTE!!!!: Currently, the update doesn't seem to work for groundwaterstations on the Lizard side.

        Parameters
        ----------
        patch_params : dict
            a dict of the parameters that should be updated.
        """
        r = requests.patch(url=self.url, headers=self.headers, data=json.dumps(patch_params))
        print(r.json())
        if r.status_code == 200:
            print(f"Groundwaterstation {self.id} successfully updated")
        else:
            raise KeyError(r.json())


    def delete_groundwaterstation(self):
        """
        Deletes the groundwaterstation.
        """
        r = requests.delete(url=self.url, headers=self.headers)
        if r.status_code == 204:
            print(f"Groundwaterstation {self.id} successfully deleted")
        elif r.status_code == 404:
            raise KeyError(r.json())
        
    def get_related_location(self, return_format: str = 'uuid'):
        """
        This method searches the location related to the groundwaterstation

        Parameters:
        -----------
        return_format : str
            options: 
                - 'uuid' (default): only returns the uuid of the location

                - 'json': returns the full data in json format of the found location


        Returns:
        --------
        string (when return_format = 'uuid')
        
        json (when return_format = 'json')
        """
        url = f"{LIZARD_BASE_URL}/locations/?object__id={self.id}&object__type=groundwaterstation"
        r = requests.get(url=url, headers=self.headers)
        count = r.json()['count']

        if count == 0:
            print(f"No locations found for groundwaterstation id {self.id}")
            return
        elif count > 1:
            print("Unexpected result: More than 1 locations are found. If that is possible, this code should be updated")
            return
        elif count == 1:
            if return_format == 'uuid':
                uuid = r.json()['results'][0]['uuid']
                return uuid
            if return_format == 'json':
                location_json = r.json()['results'][0]
                return location_json
            
    